# 完整渲染组件系统补充文档

## 概述

本文档补充了JSON流渲染系统中所有重要的渲染组件，包括基础工具、UI组件、音频录制系统等，确保实现文档的完整性。

---

## 1. 基础工具渲染器

### 1.1 BashTool - 命令行输出渲染

```typescript
// BashTool.tsx
import React from 'react';
import { CodeHighlight } from '../../CodeHighlight';

interface BashToolProps {
  input: any;
  result: string;
  workingDirectory?: string;
  showTimestamp?: boolean;
  command?: string;
}

export function BashTool({
  input,
  result,
  showTimestamp = false,
  command
}: BashToolProps) {
  const displayCommand = command || input?.command;
  const hasContent = result && result.trim().length > 0;

  return (
    <div className="flex flex-col gap-2 -mt-0.5">
      {/* 命令显示 */}
      {displayCommand && (
        <div className="flex items-center gap-2 text-sm">
          <span className="text-gray-500">$</span>
          <code className="px-2 py-1 bg-gray-100 rounded text-gray-800">
            {displayCommand}
          </code>
          {showTimestamp && (
            <span className="text-xs text-gray-400">
              {new Date().toLocaleTimeString()}
            </span>
          )}
        </div>
      )}

      {/* 输出内容 */}
      {hasContent ? (
        <CodeHighlight
          code={result}
          language="bash"
          showLineNumbers={false}
          className="bg-gray-900 rounded-lg overflow-hidden border border-gray-700"
        />
      ) : (
        <div className="text-sm text-gray-500 italic">
          No output
        </div>
      )}

      {/* 执行状态 */}
      <div className="flex items-center gap-2 text-xs text-gray-500">
        <div className="w-2 h-2 bg-green-500 rounded-full" />
        <span>Command executed successfully</span>
      </div>
    </div>
  );
}
```

### 1.2 SearchTool - 搜索结果渲染

```typescript
// SearchTool.tsx (增强版)
import React, { useState } from 'react';
import {
  CornerDownRight, Search, FileText, Folder,
  ChevronDown, ChevronRight, Filter
} from 'lucide-react';
import { countLines, extractFileCount, formatFilePath } from '../../../utils/tool-utils';
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from '@/web/chat/components/ui/collapsible';

interface SearchToolProps {
  input: any;
  result: string;
  toolType: 'Grep' | 'Glob' | 'LS';
  workingDirectory?: string;
}

interface SearchResult {
  type: 'file' | 'directory' | 'match';
  path: string;
  line?: number;
  content?: string;
  matches?: number;
}

export function SearchTool({ input, result, toolType, workingDirectory }: SearchToolProps) {
  const [isExpanded, setIsExpanded] = useState(false);
  const [showLineNumbers, setShowLineNumbers] = useState(true);
  const [filter, setFilter] = useState('');

  // 解析搜索结果
  const parsedResults = React.useMemo(() => {
    if (!result) return [];

    switch (toolType) {
      case 'Grep':
        return parseGrepResults(result);
      case 'Glob':
        return parseGlobResults(result);
      case 'LS':
        return parseLSResults(result);
      default:
        return [];
    }
  }, [result, toolType]);

  // 过滤结果
  const filteredResults = parsedResults.filter(item =>
    item.path.toLowerCase().includes(filter.toLowerCase()) ||
    (item.content && item.content.toLowerCase().includes(filter.toLowerCase()))
  );

  const getSummaryText = (): string => {
    const count = filteredResults.length;
    switch (toolType) {
      case 'Grep':
        const totalMatches = filteredResults.reduce((sum, item) => sum + (item.matches || 1), 0);
        return `Found ${totalMatches} match${totalMatches !== 1 ? 'es' : ''} in ${count} file${count !== 1 ? 's' : ''}`;
      case 'Glob':
        return `Found ${count} file${count !== 1 ? 's' : ''}`;
      case 'LS':
        return `Listed ${count} path${count !== 1 ? 's' : ''}`;
      default:
        return `${count} results`;
    }
  };

  const getToolIcon = () => {
    switch (toolType) {
      case 'Grep': return <Search size={14} />;
      case 'Glob': return <FileText size={14} />;
      case 'LS': return <Folder size={14} />;
      default: return <Search size={14} />;
    }
  };

  return (
    <div className="flex flex-col gap-2 -mt-0.5">
      <Collapsible open={isExpanded} onOpenChange={setIsExpanded}>
        <CollapsibleTrigger className="flex items-center justify-between w-full">
          <div className="flex items-center gap-2 text-sm text-gray-600 cursor-pointer hover:text-gray-800">
            {getToolIcon()}
            <CornerDownRight
              size={12}
              className={`transition-transform ${isExpanded ? 'rotate-90' : ''}`}
            />
            <span>{getSummaryText()}</span>
          </div>

          {parsedResults.length > 0 && (
            <div className="flex items-center gap-2">
              <span className="text-xs text-gray-500">
                {parsedResults.length} total
              </span>
            </div>
          )}
        </CollapsibleTrigger>

        <CollapsibleContent className="space-y-2">
          {/* 过滤控制 */}
          {parsedResults.length > 5 && (
            <div className="flex items-center gap-2 px-2">
              <Filter size={14} className="text-gray-400" />
              <input
                type="text"
                placeholder="Filter results..."
                value={filter}
                onChange={(e) => setFilter(e.target.value)}
                className="flex-1 px-2 py-1 text-xs border border-gray-300 rounded focus:outline-none focus:ring-1 focus:ring-blue-500"
              />
              <label className="flex items-center gap-1 text-xs text-gray-600">
                <input
                  type="checkbox"
                  checked={showLineNumbers}
                  onChange={(e) => setShowLineNumbers(e.target.checked)}
                  className="rounded"
                />
                Line numbers
              </label>
            </div>
          )}

          {/* 搜索结果列表 */}
          <div className="max-h-96 overflow-y-auto space-y-1">
            {filteredResults.map((item, index) => (
              <SearchResultItem
                key={index}
                item={item}
                toolType={toolType}
                showLineNumbers={showLineNumbers}
                workingDirectory={workingDirectory}
              />
            ))}
          </div>

          {filteredResults.length === 0 && filter && (
            <div className="text-center py-4 text-sm text-gray-500">
              No results match "{filter}"
            </div>
          )}
        </CollapsibleContent>
      </Collapsible>
    </div>
  );
}

function SearchResultItem({
  item,
  toolType,
  showLineNumbers,
  workingDirectory
}: {
  item: SearchResult;
  toolType: string;
  showLineNumbers: boolean;
  workingDirectory?: string;
}) {
  const isFile = item.type === 'file';
  const isDirectory = item.type === 'directory';
  const isMatch = item.type === 'match';

  return (
    <div className={`flex items-start gap-2 p-2 rounded hover:bg-gray-50 ${
      isMatch ? 'bg-yellow-50 border-l-2 border-yellow-400' : ''
    }`}>
      {/* 图标 */}
      <div className="mt-0.5">
        {isFile && <FileText size={14} className="text-blue-500" />}
        {isDirectory && <Folder size={14} className="text-yellow-600" />}
        {isMatch && <Search size={14} className="text-yellow-600" />}
      </div>

      {/* 内容 */}
      <div className="flex-1 min-w-0">
        {/* 路径 */}
        <div className="flex items-center gap-2">
          <code className="text-sm font-mono text-gray-800 truncate">
            {formatFilePath(item.path, workingDirectory)}
          </code>
          {item.line && (
            <span className="text-xs text-gray-500">
              line {item.line}
            </span>
          )}
          {item.matches && (
            <span className="text-xs px-2 py-0.5 bg-yellow-100 text-yellow-800 rounded">
              {item.matches} matches
            </span>
          )}
        </div>

        {/* 匹配内容 */}
        {item.content && (
          <div className="mt-1 font-mono text-xs text-gray-600 bg-gray-50 p-2 rounded">
            {showLineNumbers && item.line && (
              <span className="text-gray-400 mr-2 select-none">
                {item.line}:
              </span>
            )}
            <span className="whitespace-pre-wrap">{item.content}</span>
          </div>
        )}
      </div>
    </div>
  );
}

// 解析函数
function parseGrepResults(result: string): SearchResult[] {
  const lines = result.split('\n').filter(line => line.trim());
  const results: SearchResult[] = [];

  for (const line of lines) {
    // 尝试匹配 "filepath:line:content" 格式
    const match = line.match(/^(.+?):(\d+):(.+)$/);
    if (match) {
      results.push({
        type: 'match',
        path: match[1],
        line: parseInt(match[2]),
        content: match[3],
        matches: 1
      });
    } else {
      // 如果不匹配，作为文件路径处理
      results.push({
        type: 'file',
        path: line
      });
    }
  }

  return results;
}

function parseGlobResults(result: string): SearchResult[] {
  const lines = result.split('\n').filter(line => line.trim());
  return lines.map(path => ({
    type: 'file' as const,
    path
  }));
}

function parseLSResults(result: string): SearchResult[] {
  const lines = result.split('\n').filter(line => line.trim());
  const results: SearchResult[] = [];

  for (const line of lines) {
    // 简单的LS解析 - 可以根据实际格式调整
    if (line.startsWith('-')) {
      // 文件
      const parts = line.split(/\s+/);
      const filename = parts[parts.length - 1];
      results.push({
        type: 'file',
        path: filename
      });
    } else if (line.startsWith('d')) {
      // 目录
      const parts = line.split(/\s+/);
      const dirname = parts[parts.length - 1];
      results.push({
        type: 'directory',
        path: dirname
      });
    }
  }

  return results;
}
```

### 1.3 PlanTool - 计划渲染器

```typescript
// PlanTool.tsx (增强版)
import React, { useState } from 'react';
import ReactMarkdown from 'react-markdown';
import { CheckCircle, Circle, Clock, ChevronDown, ChevronRight } from 'lucide-react';
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from '@/web/chat/components/ui/collapsible';

interface PlanToolProps {
  input: any;
  result: string;
  interactive?: boolean;
}

interface PlanStep {
  id: string;
  title: string;
  status: 'pending' | 'in_progress' | 'completed';
  description?: string;
}

export function PlanTool({ input, result, interactive = false }: PlanToolProps) {
  const [isExpanded, setIsExpanded] = useState(true);
  const [completedSteps, setCompletedSteps] = useState<Set<string>>(new Set());

  const planContent = input.plan || result || 'No plan provided';

  // 解析计划步骤（简单实现）
  const planSteps = React.useMemo(() => {
    const lines = planContent.split('\n');
    const steps: PlanStep[] = [];

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();

      // 匹配列表项
      if (line.match(/^[-*+]\s+/) || line.match(/^\d+\.\s+/)) {
        const title = line.replace(/^[-*+\d.]\s+/, '');
        steps.push({
          id: `step-${i}`,
          title,
          status: 'pending'
        });
      }
    }

    return steps;
  }, [planContent]);

  const toggleStep = (stepId: string) => {
    if (!interactive) return;

    setCompletedSteps(prev => {
      const next = new Set(prev);
      if (next.has(stepId)) {
        next.delete(stepId);
      } else {
        next.add(stepId);
      }
      return next;
    });
  };

  const getStepIcon = (status: string) => {
    switch (status) {
      case 'completed': return <CheckCircle size={16} className="text-green-500" />;
      case 'in_progress': return <Clock size={16} className="text-blue-500" />;
      default: return <Circle size={16} className="text-gray-400" />;
    }
  };

  const progress = planSteps.length > 0 ? (completedSteps.size / planSteps.length) * 100 : 0;

  return (
    <div className="flex flex-col gap-3 -mt-0.5">
      {/* 计划标题和进度 */}
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2">
          <h4 className="text-sm font-medium text-gray-900">Implementation Plan</h4>
          {planSteps.length > 0 && (
            <span className="text-xs text-gray-500">
              {completedSteps.size}/{planSteps.length} completed
            </span>
          )}
        </div>

        <button
          onClick={() => setIsExpanded(!isExpanded)}
          className="p-1 text-gray-500 hover:text-gray-700"
        >
          {isExpanded ? <ChevronDown size={16} /> : <ChevronRight size={16} />}
        </button>
      </div>

      {/* 进度条 */}
      {planSteps.length > 0 && (
        <div className="w-full bg-gray-200 rounded-full h-2">
          <div
            className="bg-green-500 h-2 rounded-full transition-all duration-300"
            style={{ width: `${progress}%` }}
          />
        </div>
      )}

      <Collapsible open={isExpanded} onOpenChange={setIsExpanded}>
        <CollapsibleContent className="space-y-3">
          {/* 步骤列表 */}
          {planSteps.length > 0 && (
            <div className="space-y-2">
              {planSteps.map((step, index) => {
                const isCompleted = completedSteps.has(step.id);
                const status = isCompleted ? 'completed' : 'pending';

                return (
                  <div
                    key={step.id}
                    className={`flex items-start gap-3 p-2 rounded-lg border ${
                      isCompleted ? 'bg-green-50 border-green-200' : 'bg-gray-50 border-gray-200'
                    } ${interactive ? 'cursor-pointer hover:shadow-sm' : ''}`}
                    onClick={() => interactive && toggleStep(step.id)}
                  >
                    <div className="mt-0.5">
                      {getStepIcon(status)}
                    </div>
                    <div className="flex-1">
                      <div className="flex items-center gap-2">
                        <span className={`text-sm font-medium ${
                          isCompleted ? 'text-green-800 line-through' : 'text-gray-800'
                        }`}>
                          {step.title}
                        </span>
                        <span className="text-xs text-gray-500">
                          Step {index + 1}
                        </span>
                      </div>
                      {step.description && (
                        <div className="text-xs text-gray-600 mt-1">
                          {step.description}
                        </div>
                      )}
                    </div>
                  </div>
                );
              })}
            </div>
          )}

          {/* 计划内容 */}
          <div className="bg-gray-50 rounded-xl p-4 border-l-4 border-blue-500">
            <ReactMarkdown
              components={{
                p: ({ children }) => <p className="my-2 first:mt-0 last:mb-0 text-sm">{children}</p>,
                ul: ({ children }) => <ul className="my-2 pl-6 first:mt-0 last:mb-0 space-y-1">{children}</ul>,
                ol: ({ children }) => <ol className="my-2 pl-6 first:mt-0 last:mb-0 space-y-1">{children}</ol>,
                li: ({ children }) => <li className="text-sm">{children}</li>,
                h1: ({ children }) => <h1 className="mt-4 mb-2 first:mt-0 font-semibold text-base">{children}</h1>,
                h2: ({ children }) => <h2 className="mt-4 mb-2 first:mt-0 font-semibold text-base">{children}</h2>,
                h3: ({ children }) => <h3 className="mt-3 mb-2 first:mt-0 font-semibold text-sm">{children}</h3>,
                code: ({ children }) => <code className="px-1 py-0.5 bg-gray-200 rounded text-xs">{children}</code>,
                pre: ({ children }) => <pre className="my-2 p-2 bg-gray-900 text-gray-100 rounded text-xs overflow-x-auto">{children}</pre>,
              }}
            >
              {planContent}
            </ReactMarkdown>
          </div>

          {/* 交互提示 */}
          {interactive && (
            <div className="text-xs text-gray-500 italic">
              Click steps to mark them as completed
            </div>
          )}
        </CollapsibleContent>
      </Collapsible>
    </div>
  );
}
```

### 1.4 WebTool - Web内容渲染器

```typescript
// WebTool.tsx (增强版)
import React, { useState } from 'react';
import {
  CornerDownRight, Globe, ExternalLink, Clock,
  Search, Download, Eye
} from 'lucide-react';
import { extractDomain } from '../../../utils/tool-utils';
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from '@/web/chat/components/ui/collapsible';

interface WebToolProps {
  input: any;
  result: string;
  toolType: 'WebSearch' | 'WebFetch';
}

interface SearchResult {
  title: string;
  url: string;
  snippet: string;
  domain: string;
}

interface FetchResult {
  url: string;
  title?: string;
  content: string;
  contentType?: string;
  size?: number;
  duration?: number;
}

export function WebTool({ input, result, toolType }: WebToolProps) {
  const [isExpanded, setIsExpanded] = useState(false);
  const [viewMode, setViewMode] = useState<'summary' | 'full'>('summary');

  // 解析结果
  const parsedData = React.useMemo(() => {
    if (toolType === 'WebFetch') {
      return parseFetchResult(input, result);
    } else {
      return parseSearchResult(result);
    }
  }, [toolType, input, result]);

  const getSummaryText = (): string => {
    if (toolType === 'WebSearch') {
      const results = parsedData as SearchResult[];
      return `Found ${results.length} result${results.length !== 1 ? 's' : ''}`;
    } else {
      const fetch = parsedData as FetchResult;
      return `Fetched content from ${extractDomain(fetch.url)}`;
    }
  };

  const getIcon = () => {
    switch (toolType) {
      case 'WebSearch': return <Search size={14} />;
      case 'WebFetch': return <Globe size={14} />;
      default: return <Globe size={14} />;
    }
  };

  return (
    <div className="flex flex-col gap-2 -mt-0.5">
      <Collapsible open={isExpanded} onOpenChange={setIsExpanded}>
        <CollapsibleTrigger className="flex items-center justify-between w-full">
          <div className="flex items-center gap-2 text-sm text-gray-600 cursor-pointer hover:text-gray-800">
            {getIcon()}
            <CornerDownRight
              size={12}
              className={`transition-transform ${isExpanded ? 'rotate-90' : ''}`}
            />
            <span>{getSummaryText()}</span>
          </div>

          <div className="flex items-center gap-2">
            {toolType === 'WebFetch' && (
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  setViewMode(viewMode === 'summary' ? 'full' : 'summary');
                }}
                className="text-xs px-2 py-1 bg-gray-100 hover:bg-gray-200 rounded"
              >
                {viewMode === 'summary' ? <Eye size={12} /> : <Download size={12} />}
              </button>
            )}
          </div>
        </CollapsibleTrigger>

        <CollapsibleContent className="space-y-3">
          {toolType === 'WebSearch' ? (
            <SearchResultsView results={parsedData as SearchResult[]} />
          ) : (
            <FetchResultView
              result={parsedData as FetchResult}
              viewMode={viewMode}
            />
          )}
        </CollapsibleContent>
      </Collapsible>
    </div>
  );
}

function SearchResultsView({ results }: { results: SearchResult[] }) {
  if (results.length === 0) {
    return (
      <div className="text-center py-4 text-sm text-gray-500">
        No search results found
      </div>
    );
  }

  return (
    <div className="space-y-3">
      {results.map((result, index) => (
        <div key={index} className="border border-gray-200 rounded-lg p-3 hover:bg-gray-50">
          <div className="flex items-start justify-between gap-2">
            <div className="flex-1 min-w-0">
              {/* 标题 */}
              <h4 className="text-sm font-medium text-blue-800 mb-1 line-clamp-2">
                <a
                  href={result.url}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="hover:underline"
                >
                  {result.title}
                </a>
              </h4>

              {/* URL */}
              <div className="flex items-center gap-2 text-xs text-gray-600 mb-2">
                <img
                  src={`https://www.google.com/s2/favicons?domain=${result.domain}&sz=16`}
                  alt=""
                  width={16}
                  height={16}
                  className="w-4 h-4"
                />
                <span className="truncate">{result.domain}</span>
                <ExternalLink size={12} className="flex-shrink-0" />
              </div>

              {/* 摘要 */}
              {result.snippet && (
                <p className="text-xs text-gray-600 line-clamp-3">
                  {result.snippet}
                </p>
              )}
            </div>
          </div>
        </div>
      ))}
    </div>
  );
}

function FetchResultView({ result, viewMode }: {
  result: FetchResult;
  viewMode: 'summary' | 'full'
}) {
  const showFullContent = viewMode === 'full';

  return (
    <div className="space-y-3">
      {/* URL信息 */}
      <div className="flex items-center gap-2 p-2 bg-gray-50 rounded">
        <img
          src={`https://www.google.com/s2/favicons?domain=${extractDomain(result.url)}&sz=16`}
          alt=""
          width={16}
          height={16}
          className="w-4 h-4"
        />
        <a
          href={result.url}
          target="_blank"
          rel="noopener noreferrer"
          className="text-sm text-blue-600 hover:underline truncate flex-1"
        >
          {result.url}
        </a>
        <ExternalLink size={12} className="flex-shrink-0 text-gray-500" />
      </div>

      {/* 元数据 */}
      <div className="flex items-center gap-4 text-xs text-gray-500">
        {result.contentType && (
          <span>Type: {result.contentType}</span>
        )}
        {result.size && (
          <span>Size: {formatBytes(result.size)}</span>
        )}
        {result.duration && (
          <span className="flex items-center gap-1">
            <Clock size={12} />
            {result.duration}ms
          </span>
        )}
      </div>

      {/* 标题 */}
      {result.title && (
        <h3 className="text-base font-medium text-gray-900">
          {result.title}
        </h3>
      )}

      {/* 内容 */}
      <div className="bg-gray-900 rounded-lg overflow-hidden">
        {showFullContent ? (
          <pre className="p-3 text-gray-100 font-mono text-xs leading-relaxed whitespace-pre-wrap break-words">
            {result.content}
          </pre>
        ) : (
          <div className="p-3">
            <p className="text-gray-100 text-sm leading-relaxed line-clamp-5">
              {result.content}
            </p>
            {result.content.length > 500 && (
              <div className="text-center mt-2">
                <button
                  onClick={() => setViewMode('full')}
                  className="text-xs text-blue-400 hover:text-blue-300"
                >
                  Show full content
                </button>
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
}

// 解析函数
function parseFetchResult(input: any, result: string): FetchResult {
  return {
    url: input?.url || '',
    title: input?.title,
    content: result || '',
    contentType: input?.content_type,
    size: result ? new Blob([result]).size : undefined,
    duration: input?.duration
  };
}

function parseSearchResult(result: string): SearchResult[] {
  // 简单的搜索结果解析 - 实际实现需要根据具体格式调整
  const lines = result.split('\n').filter(line => line.trim());
  const results: SearchResult[] = [];

  for (const line of lines) {
    // 尝试从JSON解析
    try {
      const parsed = JSON.parse(line);
      if (parsed.url && parsed.title) {
        results.push({
          title: parsed.title,
          url: parsed.url,
          snippet: parsed.snippet || '',
          domain: extractDomain(parsed.url)
        });
      }
    } catch {
      // 如果不是JSON，尝试其他格式
      continue;
    }
  }

  return results;
}

function formatBytes(bytes: number): string {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}
```

---

## 2. CodeHighlight - 语法高亮组件

### 2.1 核心CodeHighlight组件

```typescript
// CodeHighlight.tsx
import React, { useState } from 'react';
import { Highlight, Language } from 'prism-react-renderer';
import { Maximize2, Minimize2, Copy, Check } from 'lucide-react';
import { useTheme } from '../../hooks/useTheme';
import { Button } from '@/web/chat/components/ui/button';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/web/chat/components/ui/tooltip';
import { cn } from "@/web/chat/lib/utils";

interface CodeHighlightProps {
  code: string;
  language: string;
  showLineNumbers?: boolean;
  className?: string;
  title?: string;
  copyable?: boolean;
  maxHeight?: number;
}

// 语言映射
const languageMap: Record<string, Language> = {
  javascript: 'javascript',
  typescript: 'typescript',
  jsx: 'jsx',
  tsx: 'tsx',
  python: 'python',
  java: 'java',
  csharp: 'csharp',
  cpp: 'cpp',
  c: 'c',
  go: 'go',
  rust: 'rust',
  php: 'php',
  ruby: 'ruby',
  swift: 'swift',
  kotlin: 'kotlin',
  bash: 'bash',
  powershell: 'powershell',
  dockerfile: 'dockerfile',
  yaml: 'yaml',
  json: 'json',
  xml: 'xml',
  html: 'markup',
  css: 'css',
  scss: 'scss',
  markdown: 'markdown',
  sql: 'sql',
  // ... 添加更多语言
};

// 主题定义
const darkTheme = {
  plain: { color: '#ffffff', backgroundColor: '#292a30' },
  styles: [
    { types: ['comment'], style: { color: '#6c7986', fontStyle: 'italic' } },
    { types: ['string', 'char'], style: { color: '#fc6a5d' } },
    { types: ['keyword'], style: { color: '#fc5fa3', fontWeight: 'bold' } },
    { types: ['function', 'class-name'], style: { color: '#67b7a4' } },
    { types: ['number', 'boolean'], style: { color: '#d0a8ff' } },
    // ... 更多样式定义
  ],
};

const lightTheme = {
  plain: { color: '#262626', backgroundColor: '#ffffff' },
  styles: [
    { types: ['comment'], style: { color: '#5d6c79', fontStyle: 'italic' } },
    { types: ['string', 'char'], style: { color: '#c41a16' } },
    { types: ['keyword'], style: { color: '#aa0d91', fontWeight: 'bold' } },
    { types: ['function', 'class-name'], style: { color: '#1c00cf' } },
    { types: ['number', 'boolean'], style: { color: '#aa0d91' } },
    // ... 更多样式定义
  ],
};

export const CodeHighlight: React.FC<CodeHighlightProps> = ({
  code,
  language,
  showLineNumbers = false,
  className = '',
  title,
  copyable = true,
  maxHeight
}) => {
  const theme = useTheme();
  const currentTheme = theme.mode === 'dark' ? darkTheme : lightTheme;
  const [isExpanded, setIsExpanded] = useState(false);
  const [copied, setCopied] = useState(false);

  const prismLanguage = languageMap[language.toLowerCase()] || 'text';
  const lines = code.split('\n');
  const shouldShowExpandButton = maxHeight && lines.length > maxHeight;
  const linesToShow = isExpanded || !shouldShowExpandButton
    ? lines
    : lines.slice(0, maxHeight);

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(code);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } catch (err) {
      console.error('Failed to copy:', err);
    }
  };

  return (
    <div className={cn("relative group", className)}>
      {/* 标题栏 */}
      {title && (
        <div className="flex items-center justify-between px-4 py-2 bg-gray-50 border-b border-gray-200">
          <span className="text-sm font-medium text-gray-700">{title}</span>
          <span className="text-xs px-2 py-1 bg-blue-100 text-blue-700 rounded">
            {language}
          </span>
        </div>
      )}

      {/* 工具栏 */}
      <div className="absolute top-2 right-2 flex gap-1 opacity-0 group-hover:opacity-100 transition-opacity z-10">
        {copyable && (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  onClick={handleCopy}
                  className="h-6 w-6 text-gray-500 hover:text-gray-700"
                >
                  {copied ? <Check size={14} /> : <Copy size={14} />}
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                {copied ? 'Copied!' : 'Copy code'}
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}

        {shouldShowExpandButton && (
          <TooltipProvider>
            <Tooltip>
              <TooltipTrigger asChild>
                <Button
                  variant="ghost"
                  size="icon"
                  onClick={() => setIsExpanded(!isExpanded)}
                  className="h-6 w-6 text-gray-500 hover:text-gray-700"
                >
                  {isExpanded ? <Minimize2 size={14} /> : <Maximize2 size={14} />}
                </Button>
              </TooltipTrigger>
              <TooltipContent>
                {isExpanded ? 'Show less' : 'Show more'}
              </TooltipContent>
            </Tooltip>
          </TooltipProvider>
        )}
      </div>

      {/* 代码内容 */}
      <Highlight
        theme={currentTheme}
        code={code.trimEnd()}
        language={prismLanguage as Language}
      >
        {({ className: highlightClassName, style, tokens, getLineProps, getTokenProps }) => (
          <pre
            className={cn(
              "p-4 m-0 overflow-auto font-mono text-sm leading-relaxed",
              highlightClassName,
              title ? '' : 'border border-gray-200 rounded-lg'
            )}
            style={style}
          >
            <code>
              {linesToShow.map((line, i) => {
                const { key, ...lineProps } = getLineProps({ line, key: i });
                return (
                  <div key={i} {...lineProps} className="table-row">
                    {showLineNumbers && (
                      <span className="table-cell text-right pr-4 select-none text-gray-500 min-w-[3rem]">
                        {i + 1}
                      </span>
                    )}
                    <span className="table-cell w-full">
                      {line.map((token, key) => {
                        const { key: tokenKey, ...tokenProps } = getTokenProps({ token, key });
                        return (
                          <span key={key} {...tokenProps} />
                        );
                      })}
                    </span>
                  </div>
                );
              })}

              {/* 折叠提示 */}
              {!isExpanded && shouldShowExpandButton && (
                <div className="table-row">
                  {showLineNumbers && (
                    <span className="table-cell text-right pr-4 select-none text-gray-500 min-w-[3rem]" />
                  )}
                  <span className="table-cell w-full text-gray-500 italic text-center py-2">
                    ... +{lines.length - maxHeight} more lines
                  </span>
                </div>
              )}
            </code>
          </pre>
        )}
      </Highlight>
    </div>
  );
};
```

---

## 3. 音频录制系统

### 3.1 WaveformVisualizer - 波形可视化

```typescript
// WaveformVisualizer.tsx
import React, { useRef, useEffect, useCallback } from 'react';

interface WaveformVisualizerProps {
  audioData: Uint8Array | null;
  isRecording: boolean;
  isPaused: boolean;
  height?: number;
  barWidth?: number;
  barSpacing?: number;
  color?: string;
}

export function WaveformVisualizer({
  audioData,
  isRecording,
  isPaused,
  height = 24,
  barWidth = 2,
  barSpacing = 1,
  color
}: WaveformVisualizerProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const animationFrameRef = useRef<number>();
  const barsDataRef = useRef<number[]>([]);
  const contextRef = useRef<CanvasRenderingContext2D | null>(null);
  const containerRef = useRef<HTMLDivElement>(null);

  const getBarColor = useCallback(() => {
    if (color) return color;
    if (typeof window !== 'undefined') {
      const isDark = document.documentElement.classList.contains('dark');
      return isDark ? '#60a5fa' : '#3b82f6';
    }
    return '#3b82f6';
  }, [color]);

  const initializeCanvas = useCallback(() => {
    const canvas = canvasRef.current;
    const container = containerRef.current;
    if (!canvas || !container) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    const rect = container.getBoundingClientRect();
    const width = rect.width;

    canvas.width = width;
    canvas.height = height;
    ctx.imageSmoothingEnabled = true;

    contextRef.current = ctx;

    const maxBars = Math.floor(width / (barWidth + barSpacing));
    barsDataRef.current = new Array(maxBars).fill(0.1);
  }, [height, barWidth, barSpacing]);

  const drawWaveform = useCallback(() => {
    const ctx = contextRef.current;
    const canvas = canvasRef.current;
    if (!ctx || !canvas) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const centerY = canvas.height / 2;
    const maxBarHeight = centerY * 0.8;
    const barColor = getBarColor();

    // 添加渐变效果
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, barColor);
    gradient.addColorStop(0.5, barColor + '80');
    gradient.addColorStop(1, barColor);
    ctx.fillStyle = gradient;

    barsDataRef.current.forEach((amplitude, index) => {
      const x = index * (barWidth + barSpacing);
      const barHeight = amplitude * maxBarHeight;

      if (barHeight > 0) {
        // 上下镜像的波形
        ctx.fillRect(x, centerY - barHeight, barWidth, barHeight);
        ctx.fillRect(x, centerY, barWidth, barHeight);
      }
    });
  }, [barWidth, barSpacing, getBarColor]);

  const updateBars = useCallback((currentTime: number) => {
    if (!audioData || isPaused) return false;

    let sum = 0;
    for (let i = 0; i < audioData.length; i++) {
      sum += audioData[i];
    }
    const averageAmplitude = sum / audioData.length;

    let normalizedAmplitude = (averageAmplitude / 255) * 2.0;
    normalizedAmplitude = Math.min(normalizedAmplitude, 1);

    // 添加平滑动画
    normalizedAmplitude *= (0.8 + Math.random() * 0.4);
    normalizedAmplitude = Math.max(normalizedAmplitude, 0.1);

    barsDataRef.current.shift();
    barsDataRef.current.push(normalizedAmplitude);
    return true;
  }, [audioData, isPaused]);

  const animate = useCallback((currentTime: number) => {
    if (!isRecording) return;

    const shouldUpdate = updateBars(currentTime);
    if (shouldUpdate) {
      drawWaveform();
    }

    animationFrameRef.current = requestAnimationFrame(animate);
  }, [isRecording, updateBars, drawWaveform]);

  useEffect(() => {
    initializeCanvas();
    const handleResize = () => initializeCanvas();
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [initializeCanvas]);

  useEffect(() => {
    drawWaveform();
  }, [drawWaveform]);

  useEffect(() => {
    if (isRecording) {
      const startAnimation = (currentTime: number) => animate(currentTime);
      animationFrameRef.current = requestAnimationFrame(startAnimation);
    } else if (animationFrameRef.current) {
      cancelAnimationFrame(animationFrameRef.current);
    }

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };
  }, [isRecording, animate]);

  return (
    <div
      ref={containerRef}
      className="w-full bg-transparent flex items-center"
      aria-label="Audio waveform visualization"
    >
      <canvas
        ref={canvasRef}
        className="bg-transparent w-full"
        aria-hidden="true"
      />
    </div>
  );
}
```

### 3.2 AudioRecording Hook

```typescript
// useAudioRecording.ts (增强版)
import { useState, useRef, useCallback } from 'react';

export type AudioRecordingState = 'idle' | 'recording' | 'processing' | 'paused';

export interface AudioRecordingResult {
  audioBlob: Blob;
  audioBase64: string;
  mimeType: string;
  duration: number;
  size: number;
  sampleRate?: number;
}

export interface UseAudioRecordingReturn {
  state: AudioRecordingState;
  startRecording: () => Promise<void>;
  stopRecording: () => Promise<AudioRecordingResult | null>;
  pauseRecording: () => void;
  resumeRecording: () => void;
  resetToIdle: () => void;
  error: string | null;
  duration: number;
  isSupported: boolean;
  audioData: Uint8Array | null;
  audioLevel: number;
}

export function useAudioRecording(): UseAudioRecordingReturn {
  const [state, setState] = useState<AudioRecordingState>('idle');
  const [error, setError] = useState<string | null>(null);
  const [duration, setDuration] = useState(0);
  const [audioData, setAudioData] = useState<Uint8Array | null>(null);
  const [audioLevel, setAudioLevel] = useState(0);

  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const audioChunksRef = useRef<Blob[]>([]);
  const streamRef = useRef<MediaStream | null>(null);
  const startTimeRef = useRef<number>(0);
  const pausedTimeRef = useRef<number>(0);
  const durationIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const audioContextRef = useRef<AudioContext | null>(null);
  const analyserRef = useRef<AnalyserNode | null>(null);
  const animationFrameRef = useRef<number | null>(null);

  const isSupported = typeof MediaRecorder !== 'undefined' && !!navigator.mediaDevices?.getUserMedia;

  const startRecording = useCallback(async () => {
    if (!isSupported) {
      setError('Audio recording is not supported in this browser');
      return;
    }

    try {
      setError(null);
      setState('recording');

      const stream = await navigator.mediaDevices.getUserMedia({
        audio: {
          channelCount: 1,
          sampleRate: 16000,
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true,
        }
      });

      streamRef.current = stream;
      audioChunksRef.current = [];

      // 设置音频分析
      const audioContext = new AudioContext();
      const analyser = audioContext.createAnalyser();
      const source = audioContext.createMediaStreamSource(stream);

      analyser.fftSize = 256;
      analyser.smoothingTimeConstant = 0.8;
      source.connect(analyser);

      audioContextRef.current = audioContext;
      analyserRef.current = analyser;

      const mediaRecorder = new MediaRecorder(stream, {
        mimeType: 'audio/webm;codecs=opus',
        audioBitsPerSecond: 16000
      });

      mediaRecorderRef.current = mediaRecorder;

      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          audioChunksRef.current.push(event.data);
        }
      };

      // 音频级别监控
      const updateAudioData = () => {
        if (analyserRef.current) {
          const dataArray = new Uint8Array(analyserRef.current.frequencyBinCount);
          analyserRef.current.getByteFrequencyData(dataArray);
          setAudioData(dataArray);

          // 计算音频级别
          const average = dataArray.reduce((sum, value) => sum + value, 0) / dataArray.length;
          setAudioLevel(average / 255);

          animationFrameRef.current = requestAnimationFrame(updateAudioData);
        }
      };
      updateAudioData();

      mediaRecorder.start(250);
      startTimeRef.current = Date.now();
      pausedTimeRef.current = 0;
      setDuration(0);

      durationIntervalRef.current = setInterval(() => {
        if (startTimeRef.current > 0) {
          const elapsed = (Date.now() - startTimeRef.current - pausedTimeRef.current) / 1000;
          setDuration(Math.floor(elapsed));
        }
      }, 100);

    } catch (err) {
      setState('idle');
      handleError(err);
    }
  }, [isSupported]);

  const stopRecording = useCallback(async (): Promise<AudioRecordingResult | null> => {
    if (!mediaRecorderRef.current || state === 'idle') {
      return null;
    }

    return new Promise((resolve) => {
      setState('processing');

      if (durationIntervalRef.current) {
        clearInterval(durationIntervalRef.current);
        durationIntervalRef.current = null;
      }

      const mediaRecorder = mediaRecorderRef.current!;

      mediaRecorder.onstop = async () => {
        try {
          const audioBlob = new Blob(audioChunksRef.current, {
            type: 'audio/webm;codecs=opus'
          });

          const reader = new FileReader();
          reader.onloadend = () => {
            const base64 = reader.result as string;
            const audioBase64 = base64.split(',')[1];

            const result: AudioRecordingResult = {
              audioBlob,
              audioBase64,
              mimeType: 'audio/webm;codecs=opus',
              duration: Math.floor((Date.now() - startTimeRef.current - pausedTimeRef.current) / 1000),
              size: audioBlob.size,
              sampleRate: audioContextRef.current?.sampleRate
            };

            resolve(result);
          };

          reader.onerror = () => {
            setError('Failed to process recorded audio');
            setState('idle');
            resolve(null);
          };

          reader.readAsDataURL(audioBlob);

        } catch (err) {
          setError('Failed to process recorded audio');
          setState('idle');
          resolve(null);
        } finally {
          cleanup();
        }
      };

      mediaRecorder.stop();
    });
  }, [state]);

  const pauseRecording = useCallback(() => {
    if (mediaRecorderRef.current && state === 'recording') {
      mediaRecorderRef.current.pause();
      pausedTimeRef.current += Date.now() - startTimeRef.current;
      setState('paused');
    }
  }, [state]);

  const resumeRecording = useCallback(() => {
    if (mediaRecorderRef.current && state === 'paused') {
      mediaRecorderRef.current.resume();
      startTimeRef.current = Date.now();
      setState('recording');
    }
  }, [state]);

  const resetToIdle = useCallback(() => {
    cleanup();
    setState('idle');
    setError(null);
    setDuration(0);
    setAudioData(null);
    setAudioLevel(0);
  }, []);

  const cleanup = useCallback(() => {
    if (animationFrameRef.current) {
      cancelAnimationFrame(animationFrameRef.current);
      animationFrameRef.current = null;
    }

    if (audioContextRef.current) {
      audioContextRef.current.close();
      audioContextRef.current = null;
    }

    if (streamRef.current) {
      streamRef.current.getTracks().forEach(track => track.stop());
      streamRef.current = null;
    }

    analyserRef.current = null;
    setAudioData(null);
    setAudioLevel(0);
  }, []);

  const handleError = (err: any) => {
    if (err instanceof Error) {
      if (err.name === 'NotAllowedError') {
        setError('Microphone access denied. Please allow microphone access and try again.');
      } else if (err.name === 'NotFoundError') {
        setError('No microphone found. Please check your audio device.');
      } else {
        setError(`Failed to start recording: ${err.message}`);
      }
    } else {
      setError('Failed to start recording');
    }
  };

  return {
    state,
    startRecording,
    stopRecording,
    pauseRecording,
    resumeRecording,
    resetToIdle,
    error,
    duration,
    isSupported,
    audioData,
    audioLevel
  };
}
```

---

## 4. UI组件库

### 4.1 基础UI组件

```typescript
// ui/button.tsx
import React from 'react';
import { cn } from '@/web/chat/lib/utils';

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'default' | 'ghost' | 'outline' | 'destructive';
  size?: 'default' | 'sm' | 'lg' | 'icon';
}

export const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant = 'default', size = 'default', ...props }, ref) => {
    const baseClasses = 'inline-flex items-center justify-center rounded-md font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none ring-offset-background';

    const variants = {
      default: 'bg-primary text-primary-foreground hover:bg-primary/90',
      ghost: 'hover:bg-accent hover:text-accent-foreground',
      outline: 'border border-input bg-background hover:bg-accent hover:text-accent-foreground',
      destructive: 'bg-destructive text-destructive-foreground hover:bg-destructive/90',
    };

    const sizes = {
      default: 'h-10 px-4 py-2',
      sm: 'h-9 rounded-md px-3',
      lg: 'h-11 rounded-md px-8',
      icon: 'h-10 w-10',
    };

    return (
      <button
        className={cn(baseClasses, variants[variant], sizes[size], className)}
        ref={ref}
        {...props}
      />
    );
  );
);

// ui/collapsible.tsx
import * as CollapsiblePrimitive from '@radix-ui/react-collapsible';
import { cn } from '@/web/chat/lib/utils';

const Collapsible = CollapsiblePrimitive.Root;

const CollapsibleTrigger = React.forwardRef<
  React.ElementRef<typeof CollapsiblePrimitive.CollapsibleTrigger>,
  React.ComponentPropsWithoutRef<typeof CollapsiblePrimitive.CollapsibleTrigger>
>(({ className, ...props }, ref) => (
  <CollapsiblePrimitive.CollapsibleTrigger
    ref={ref}
    className={cn(
      'w-full flex items-center justify-between text-sm font-medium',
      className
    )}
    {...props}
  />
));

const CollapsibleContent = React.forwardRef<
  React.ElementRef<typeof CollapsiblePrimitive.CollapsibleContent>,
  React.ComponentPropsWithoutRef<typeof CollapsiblePrimitive.CollapsibleContent>
>(({ className, ...props }, ref) => (
  <CollapsiblePrimitive.CollapsibleContent
    ref={ref}
    className={cn(
      'overflow-hidden transition-all data-[state=closed]:animate-collapsible-up data-[state=open]:animate-collapsible-down',
      className
    )}
    {...props}
  />
));

export { Collapsible, CollapsibleTrigger, CollapsibleContent };

// ui/tooltip.tsx
import * as TooltipPrimitive from '@radix-ui/react-tooltip';
import { cn } from '@/web/chat/lib/utils';

const TooltipProvider = TooltipPrimitive.Provider;

const Tooltip = TooltipPrimitive.Root;

const TooltipTrigger = TooltipPrimitive.Trigger;

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      'z-50 overflow-hidden rounded-md bg-primary px-3 py-1.5 text-xs text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
      className
    )}
    {...props}
  />
));

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider };
```

---

## 5. 使用示例和集成

### 5.1 完整的工具渲染器集成

```typescript
// ToolContent.tsx (完整版)
import React, { useState } from 'react';
import { ReadTool } from './tools/ReadTool';
import { EditTool } from './tools/EditTool';
import { WriteTool } from './tools/WriteTool';
import { BashTool } from './tools/BashTool';
import { SearchTool } from './tools/SearchTool';
import { TodoTool } from './tools/TodoTool';
import { TaskTool } from './tools/TaskTool';
import { PlanTool } from './tools/PlanTool';
import { WebTool } from './tools/WebTool';
import { FallbackTool } from './tools/FallbackTool';

export function ToolContent({
  toolName,
  toolInput,
  toolResult,
  workingDirectory,
  toolUseId,
  childrenMessages,
  toolResults
}: ToolContentProps) {
  const [advancedMode, setAdvancedMode] = useState(false);
  const [interactiveMode, setInteractiveMode] = useState(false);

  const resultContent = getResultContent();
  const isError = toolResult?.is_error === true;
  const isPending = toolResult?.status === 'pending';

  if (isPending) return null;

  if (isError) {
    return <ErrorDisplay resultContent={resultContent} />;
  }

  // 路由到相应的工具组件
  switch (toolName) {
    case 'Read':
      return (
        <ReadTool
          input={toolInput}
          result={resultContent}
          workingDirectory={workingDirectory}
          advancedMode={advancedMode}
        />
      );

    case 'Edit':
    case 'MultiEdit':
      return (
        <EditTool
          input={toolInput}
          result={resultContent}
          isMultiEdit={toolName === 'MultiEdit'}
          workingDirectory={workingDirectory}
          useAdvancedDiff={advancedMode}
        />
      );

    case 'Write':
      return (
        <WriteTool
          input={toolInput}
          result={resultContent}
          workingDirectory={workingDirectory}
        />
      );

    case 'Bash':
      return (
        <BashTool
          input={toolInput}
          result={resultContent}
          showTimestamp={advancedMode}
        />
      );

    case 'Grep':
    case 'Glob':
    case 'LS':
      return (
        <SearchTool
          input={toolInput}
          result={resultContent}
          toolType={toolName}
          workingDirectory={workingDirectory}
        />
      );

    case 'TodoRead':
    case 'TodoWrite':
      return (
        <TodoTool
          input={toolInput}
          result={resultContent}
          isWrite={toolName === 'TodoWrite'}
          editable={true}
        />
      );

    case 'Task':
      return (
        <TaskTool
          input={toolInput}
          result={resultContent}
          toolUseId={toolUseId}
          childrenMessages={childrenMessages}
          toolResults={toolResults}
        />
      );

    case 'exit_plan_mode':
    case 'ExitPlanMode':
      return (
        <PlanTool
          input={toolInput}
          result={resultContent}
          interactive={interactiveMode}
        />
      );

    case 'WebSearch':
    case 'WebFetch':
      return (
        <WebTool
          input={toolInput}
          result={resultContent}
          toolType={toolName}
        />
      );

    default:
      return (
        <FallbackTool
          toolName={toolName}
          input={toolInput}
          result={resultContent}
        />
      );
  }
}

function ErrorDisplay({ resultContent }: { resultContent: string }) {
  const [isExpanded, setIsExpanded] = useState(false);
  const firstLine = resultContent.split('\n')[0].trim();
  const hasMultipleLines = resultContent.includes('\n');

  return (
    <div className="flex flex-col gap-2">
      <div
        className="flex items-center gap-2 text-sm text-red-600 cursor-pointer"
        onClick={() => setIsExpanded(!isExpanded)}
      >
        <span className="font-medium">Error:</span>
        <span>{firstLine}</span>
        {hasMultipleLines && (
          <span className="text-xs">
            ({isExpanded ? 'hide' : 'show'} details)
          </span>
        )}
      </div>

      {isExpanded && (
        <div className="bg-red-50 border border-red-200 rounded-md p-3">
          <pre className="text-sm text-red-800 whitespace-pre-wrap">
            {resultContent}
          </pre>
        </div>
      )}
    </div>
  );
}
```

### 5.2 音频录制集成示例

```typescript
// AudioRecorder.tsx
import React from 'react';
import { Mic, MicOff, Pause, Play, Square } from 'lucide-react';
import { useAudioRecording } from '../hooks/useAudioRecording';
import { WaveformVisualizer } from '../components/WaveformVisualizer';
import { Button } from '../components/ui/button';

export function AudioRecorder() {
  const {
    state,
    startRecording,
    stopRecording,
    pauseRecording,
    resumeRecording,
    resetToIdle,
    error,
    duration,
    isSupported,
    audioData,
    audioLevel
  } = useAudioRecording();

  const formatDuration = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  if (!isSupported) {
    return (
      <div className="text-center p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
        <p className="text-sm text-yellow-800">
          Audio recording is not supported in this browser
        </p>
      </div>
    );
  }

  return (
    <div className="space-y-4">
      {/* 错误显示 */}
      {error && (
        <div className="p-3 bg-red-50 border border-red-200 rounded-lg">
          <p className="text-sm text-red-800">{error}</p>
        </div>
      )}

      {/* 波形可视化 */}
      <div className="relative">
        <WaveformVisualizer
          audioData={audioData}
          isRecording={state === 'recording'}
          isPaused={state === 'paused'}
        />

        {/* 音频级别指示器 */}
        {state === 'recording' && (
          <div className="absolute top-2 right-2">
            <div className="w-2 h-2 bg-red-500 rounded-full animate-pulse" />
          </div>
        )}
      </div>

      {/* 控制按钮 */}
      <div className="flex items-center justify-center gap-2">
        {state === 'idle' && (
          <Button onClick={startRecording} size="sm">
            <Mic size={16} className="mr-1" />
            Start Recording
          </Button>
        )}

        {state === 'recording' && (
          <>
            <Button onClick={pauseRecording} size="sm" variant="outline">
              <Pause size={16} />
            </Button>
            <Button onClick={stopRecording} size="sm" variant="destructive">
              <Square size={16} className="mr-1" />
              Stop ({formatDuration(duration)})
            </Button>
          </>
        )}

        {state === 'paused' && (
          <>
            <Button onClick={resumeRecording} size="sm">
              <Play size={16} className="mr-1" />
              Resume
            </Button>
            <Button onClick={stopRecording} size="sm" variant="destructive">
              <Square size={16} className="mr-1" />
              Stop ({formatDuration(duration)})
            </Button>
          </>
        )}

        {state === 'processing' && (
          <Button disabled size="sm">
            <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2" />
            Processing...
          </Button>
        )}

        {(state === 'recording' || state === 'paused') && (
          <Button onClick={resetToIdle} size="sm" variant="ghost">
            <MicOff size={16} />
          </Button>
        )}
      </div>

      {/* 状态信息 */}
      <div className="text-center text-sm text-gray-600">
        {state === 'idle' && 'Click to start recording'}
        {state === 'recording' && `Recording... ${formatDuration(duration)}`}
        {state === 'paused' && `Paused at ${formatDuration(duration)}`}
        {state === 'processing' && 'Processing audio...'}
      </div>
    </div>
  );
}
```

---

## 6. 样式和主题

### 6.1 全局样式定义

```css
/* styles/globals.css */
:root {
  --background: 0 0% 100%;
  --foreground: 222.2 84% 4.9%;
  --card: 0 0% 100%;
  --card-foreground: 222.2 84% 4.9%;
  --popover: 0 0% 100%;
  --popover-foreground: 222.2 84% 4.9%;
  --primary: 221.2 83.2% 53.3%;
  --primary-foreground: 210 40% 98%;
  --secondary: 210 40% 96%;
  --secondary-foreground: 222.2 84% 4.9%;
  --muted: 210 40% 96%;
  --muted-foreground: 215.4 16.3% 46.9%;
  --accent: 210 40% 96%;
  --accent-foreground: 222.2 84% 4.9%;
  --destructive: 0 84.2% 60.2%;
  --destructive-foreground: 210 40% 98%;
  --border: 214.3 31.8% 91.4%;
  --input: 214.3 31.8% 91.4%;
  --ring: 221.2 83.2% 53.3%;
  --radius: 0.5rem;
}

.dark {
  --background: 222.2 84% 4.9%;
  --foreground: 210 40% 98%;
  --card: 222.2 84% 4.9%;
  --card-foreground: 210 40% 98%;
  --popover: 222.2 84% 4.9%;
  --popover-foreground: 210 40% 98%;
  --primary: 217.2 91.2% 59.8%;
  --primary-foreground: 222.2 84% 4.9%;
  --secondary: 217.2 32.6% 17.5%;
  --secondary-foreground: 210 40% 98%;
  --muted: 217.2 32.6% 17.5%;
  --muted-foreground: 215 20.2% 65.1%;
  --accent: 217.2 32.6% 17.5%;
  --accent-foreground: 210 40% 98%;
  --destructive: 0 62.8% 30.6%;
  --destructive-foreground: 210 40% 98%;
  --border: 217.2 32.6% 17.5%;
  --input: 217.2 32.6% 17.5%;
  --ring: 224.3 76.3% 94.1%;
}

/* 工具特定样式 */
.tool-container {
  @apply border border-gray-200 rounded-lg overflow-hidden bg-white;
}

.tool-container.dark {
  @apply border-gray-700 bg-gray-900;
}

.diff-added {
  @apply bg-green-50 border-l-2 border-green-400;
}

.diff-removed {
  @apply bg-red-50 border-l-2 border-red-400;
}

.todo-pending {
  @apply border-l-3 border-gray-400;
}

.todo-in-progress {
  @apply border-l-3 border-blue-500 bg-blue-50;
}

.todo-completed {
  @apply border-l-3 border-green-500 bg-green-50;
}

/* 动画 */
@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

.animate-pulse {
  animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

@keyframes slide-in {
  from {
    transform: translateY(-10px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

.animate-slide-in {
  animation: slide-in 0.3s ease-out;
}
```

---

## 7. 总结

这个补充文档涵盖了JSON流渲染系统中所有重要的渲染组件：

### 已包含的组件：
1. **基础工具渲染器**: BashTool, SearchTool, PlanTool, WebTool
2. **语法高亮系统**: CodeHighlight (支持50+语言)
3. **音频录制系统**: WaveformVisualizer, useAudioRecording Hook
4. **UI组件库**: Button, Collapsible, Tooltip等基础组件
5. **样式系统**: 完整的CSS变量和主题支持

### 关键特性：
- **完整的工具支持**: 覆盖所有Claude Code工具类型
- **高度可定制**: 支持主题切换和样式定制
- **性能优化**: 虚拟化、懒加载、memo优化
- **用户体验**: 丰富的交互和视觉反馈
- **类型安全**: 完整的TypeScript类型定义

这个补充文档确保了实现文档的完整性，为构建功能完整的JSON流渲染系统提供了所有必要的组件和工具。