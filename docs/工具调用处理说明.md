# 工具调用处理完整说明

## 一、数据流程概述

### 1. 用户请求流程

```
用户发送消息（携带 MCP 配置）
    ↓
前端调用 /v1/messages 接口
    ↓
后端 @musistudio/llms 处理请求
    ↓
返回 SSE 流式响应
```

### 2. 后端返回的数据格式

后端会返回两种类型的流式事件：

#### A. 普通文本块

```json
{
  "type": "content_block_delta",
  "delta": {
    "text": "这是文本内容..."
  }
}
```

#### B. 工具调用块（MCP 工具）

```json
// 1. 工具调用开始
{
  "type": "content_block_start",
  "index": 1,
  "content_block": {
    "type": "tool_use",
    "id": "call_d7702f11de6a4237b69bdf55",
    "name": "mcp__context7__resolve-library-id",
    "input": {}
  }
}

// 2. 工具参数流式传输（可能分多次）
{
  "type": "content_block_delta",
  "index": 1,
  "delta": {
    "type": "input_json_delta",
    "partial_json": "{\"query\": \"vue documentation\", \"libraryName\": \"vue\"}"
  }
}

// 3. 工具调用结束
{
  "type": "content_block_stop",
  "index": 1
}
```

**注意**：根据后端代码 `usageCacheMiddleware.js`，如果工具调用被后端中间件拦截并自动执行，这些事件可能**不会**传递给前端。需要确认后端配置。

## 二、前端处理流程

### 1. 解析流式事件

在 `useSSEStream.ts` 中，需要添加对工具调用事件的解析：

```typescript
// 在 useSSEStream.ts 中添加
case "content_block_start":
  if (data.content_block?.type === "tool_use") {
    // 开始收集工具调用数据
    callbacks.onToolCallStart?.({
      index: data.index,
      toolCallId: data.content_block.id,
      toolName: data.content_block.name,
    });
  }
  break;

case "content_block_delta":
  if (data.delta?.type === "input_json_delta") {
    // 累积工具参数
    callbacks.onToolCallDelta?.({
      index: data.index,
      partialJson: data.delta.partial_json,
    });
  }
  break;

case "content_block_stop":
  // 工具调用完成
  callbacks.onToolCallStop?.({
    index: data.index,
  });
  break;
```

### 2. 转换为 ToolUIPart 格式

`ai-elements-vue` 的 Tool 组件需要 `ToolUIPart` 格式的数据（来自 `ai` 包）：

```typescript
interface ToolUIPart {
  type: string; // 例如: "tool-mcp__context7__resolve-library-id"
  toolCallId: string; // 工具调用 ID
  state:
    | "input-streaming" // 正在接收输入参数
    | "input-available" // 输入参数已接收完成
    | "approval-requested" // 等待用户批准
    | "approval-responded" // 用户已响应
    | "output-available" // 输出可用
    | "output-error" // 执行错误
    | "output-denied"; // 被拒绝
  input: Record<string, unknown>; // 工具输入参数
  output?: unknown; // 工具执行结果（可选）
  errorText?: string; // 错误信息（可选）
}
```

### 3. 转换函数示例

```typescript
// utils/toolCallParser.ts
import type { ToolUIPart } from "ai";
import type { SSEEvent } from "../types";

interface ToolCallState {
  toolCallId: string;
  toolName: string;
  inputJson: string;
  state: ToolUIPart["state"];
}

export function parseToolCallEvents(events: SSEEvent[]): ToolUIPart[] {
  const toolCallsMap = new Map<number, ToolCallState>();

  for (const event of events) {
    // 处理工具调用开始
    if (
      event.type === "content_block_start" &&
      event.content_block?.type === "tool_use"
    ) {
      const index = event.index ?? 0;
      const toolCallId = event.content_block.id || `tool-${index}`;
      const toolName = event.content_block.name || "unknown";

      toolCallsMap.set(index, {
        toolCallId,
        toolName,
        inputJson: "",
        state: "input-streaming",
      });
    }

    // 处理工具参数增量
    if (
      event.type === "content_block_delta" &&
      event.delta?.type === "input_json_delta"
    ) {
      const index = event.index ?? 0;
      const state = toolCallsMap.get(index);
      if (state) {
        state.inputJson += event.delta.partial_json || "";
        state.state = "input-streaming";
      }
    }

    // 处理工具调用结束
    if (event.type === "content_block_stop") {
      const index = event.index ?? 0;
      const state = toolCallsMap.get(index);
      if (state) {
        state.state = "input-available";
      }
    }
  }

  // 转换为 ToolUIPart 数组
  return Array.from(toolCallsMap.values()).map((state) => {
    let input = {};
    try {
      input = JSON.parse(state.inputJson);
    } catch (e) {
      console.error("解析工具参数失败:", e);
    }

    return {
      type: `tool-${state.toolName}`,
      toolCallId: state.toolCallId,
      state: state.state,
      input,
    };
  });
}
```

## 三、前端渲染

### 1. 在 ChatMessages.vue 中渲染工具调用

```vue
<template>
  <MessageContent class="max-w-full">
    <!-- 工具调用渲染 -->
    <div v-if="version.toolCalls?.length" class="space-y-2 mb-2">
      <Tool
        v-for="(toolCall, index) in version.toolCalls"
        :key="toolCall.toolCallId || index"
        :default-open="toolCall.state === 'input-streaming'"
      >
        <ToolHeader
          :state="toolCall.state"
          :type="toolCall.type"
          :title="getToolTitle(toolCall.type)"
        />
        <ToolContent>
          <ToolInput :input="toolCall.input" />
          <ToolOutput
            v-if="toolCall.output || toolCall.errorText"
            :output="toolCall.output"
            :error-text="toolCall.errorText"
          />
        </ToolContent>
      </Tool>
    </div>

    <!-- 其他内容... -->
    <MessageResponse v-else :content="version.content" />
  </MessageContent>
</template>

<script setup lang="ts">
import {
  Tool,
  ToolContent,
  ToolHeader,
  ToolInput,
  ToolOutput,
} from "@/components/ai-elements/tool";

function getToolTitle(toolType: string): string {
  // 从 "tool-mcp__context7__resolve-library-id" 提取 "resolve-library-id"
  return toolType.split("-").slice(1).join(" ");
}
</script>
```

## 四、工具执行流程（如果需要前端调用）

### 当前后端行为

根据 `usageCacheMiddleware.js`，后端**会自动执行工具**：

1. 检测到工具调用 → 拦截事件
2. 收集工具参数 → 解析 JSON
3. 执行工具 → 调用 MCP 服务器
4. 获取结果 → 自动发送回模型
5. 模型继续生成 → 基于工具结果生成回复

**这意味着**：如果后端配置了自动执行，前端**不需要**手动调用工具，只需要渲染工具调用和结果。

### 如果需要前端手动调用工具

如果后端**不自动执行**工具，前端需要：

1. **检测工具调用完成**（收到 `content_block_stop`）
2. **调用工具执行接口**：

   ```typescript
   // 使用 useMcpApi
   import { useMcpApi } from "@/hooks/useMcpApi";

   const { callTool } = useMcpApi();

   // 调用工具
   const result = await callTool(
     group, // MCP 服务器组名
     toolName, // 工具名称（去掉 mcp__ 前缀）
     input, // 工具参数
     undefined, // serverConfig
     sessionId // 会话 ID
   );
   ```

3. **更新工具调用状态**：
   ```typescript
   // 更新 toolCall 的 state 和 output
   toolCall.state = "output-available";
   toolCall.output = result;
   ```

## 五、数据存储

### 在 MessageVersion 中存储工具调用

```typescript
// types.ts
export interface MessageVersion {
  id: string;
  content: string;
  files?: FileUIPart[];
  toolCalls?: ToolUIPart[]; // 添加工具调用数组
}
```

### 在流式处理中累积工具调用

```typescript
// ChatPanel.vue 或 useSSEStream.ts
const currentToolCalls = ref<Map<number, ToolUIPart>>(new Map());

// 处理工具调用事件
onToolCallStart(({ index, toolCallId, toolName }) => {
  currentToolCalls.value.set(index, {
    type: `tool-${toolName}`,
    toolCallId,
    state: "input-streaming",
    input: {},
  });
});

onToolCallDelta(({ index, partialJson }) => {
  const toolCall = currentToolCalls.value.get(index);
  if (toolCall) {
    // 累积 JSON
    const currentInput = toolCall.input as Record<string, unknown>;
    try {
      const partial = JSON.parse(partialJson);
      Object.assign(currentInput, partial);
    } catch (e) {
      // 处理解析错误
    }
  }
});

onToolCallStop(({ index }) => {
  const toolCall = currentToolCalls.value.get(index);
  if (toolCall) {
    toolCall.state = "input-available";

    // 如果需要前端调用工具，在这里调用
    // await executeTool(toolCall);

    // 将工具调用添加到消息版本
    if (!currentVersion.toolCalls) {
      currentVersion.toolCalls = [];
    }
    currentVersion.toolCalls.push(toolCall);
  }
});
```

## 六、关键问题

### 1. 后端是否传递工具调用事件？

**需要确认**：检查后端 `usageCacheMiddleware.js` 是否返回 `undefined`（隐藏事件）。

- 如果返回 `undefined`：前端**收不到**工具调用事件，需要后端修改
- 如果正常传递：前端可以正常解析和渲染

### 2. 工具执行时机

- **后端自动执行**（推荐）：前端只需渲染
- **前端手动执行**：需要调用 `useMcpApi().callTool()`

### 3. 工具结果如何获取？

- **后端自动执行**：工具结果会作为新的消息内容返回
- **前端手动执行**：需要调用工具接口，然后更新 `toolCall.output`

## 七、实现步骤

1. ✅ **扩展类型定义**：在 `MessageVersion` 中添加 `toolCalls`
2. ✅ **更新 SSE 事件处理**：在 `useSSEStream.ts` 中添加工具调用事件处理
3. ✅ **创建转换函数**：将流式事件转换为 `ToolUIPart` 格式
4. ✅ **更新渲染组件**：在 `ChatMessages.vue` 中使用 Tool 组件渲染
5. ⚠️ **确认后端行为**：检查后端是否传递工具调用事件
6. ⚠️ **处理工具执行**：根据后端行为决定是否需要前端调用工具

## 八、参考资源

- [ai-elements-vue Tool 组件文档](https://www.ai-elements-vue.com/components/tool)
- [@musistudio/llms 文档](https://github.com/musistudio/llms)
- [Vercel AI SDK ToolUIPart 类型](https://sdk.vercel.ai/docs/reference/ai-sdk-core/tool-ui-part)
